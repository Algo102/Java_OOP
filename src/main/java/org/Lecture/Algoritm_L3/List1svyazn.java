package org.Lecture.Algoritm_L3;
//Односвязный список содержит ссылки на следующий элемент списка
public class List1svyazn {
    Node head; // начало списка - ссылка на голову
    //Node tail; // cсылка последнюю ноду - хвост, может и не быть
    // Технически конец может быть, но от него нет смысла, если не
    // добавлять элементы ссылаясь на хвост, к примеру работа с очередями
    // односвязный список с конца обойти не возможно


    // Упростим функцию перевызовом. Так же нужно учитывать, запускаем разворот,
    // если есть 2 ноды и больше, если нет элементов или он один, то разворачивать нечего
    public void revert(){
        if(head != null && head.next != null) {
            Node temp = head; // Создаем временую Ноду и помещаем туда Head
            revert(head.next, head);
            temp.next = null;
        }
    }

    // Разворот в односвязном списке происходит с помощью рекурсии, так как есть
    // ссылка только на следующий элемент
    // В аргументах ссылки на текущую и предидущую Ноду
    private void revert(Node currentNode, Node previousNode){
        // Как только дошли до конца списка, и увидели что следующего элемента нет,
        // то последний элемент записываем как голову
        if(currentNode.next == null)
            head = currentNode;
            // если элемент есть, то запускаем рекурсию с аргументами, где текущий
            // будет next, а предыдущее значение становится текущий currentNode
        else
            revert(currentNode.next, currentNode);
        // И запускаем операцию замены ссылок, тем самым запустили обратное значение
        currentNode.next = previousNode;

    }

    public class Node{
        //могут хранить разные типы данный, для простоты int
        int value; // Значение ноды
        Node next; // у односвязного списка есть ссылка, которая описывает след.элемент
        // Односвязный список обойти с конца не возможно, так как нет ссылки на
        // предидущее значение
    }

}
